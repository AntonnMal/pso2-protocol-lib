#ifndef psopacketlib_ffi_h
#define psopacketlib_ffi_h

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

#define API_VERSION 5

#define PROTOCOL_VERSION 4

typedef enum Direction {
  ToServer,
  ToClient,
} Direction;

typedef enum OutputType {
  /**
   * Output only parsed packet.
   */
  OutputPacket,
  /**
   * Output only raw packet.
   */
  OutputRaw,
  /**
   * Output both packets.
   */
  OutputBoth,
} OutputType;

/**
 * Packet types.
 */
typedef enum PacketType {
  NGS,
  Classic,
  NA,
  JP,
  Vita,
  Raw,
} PacketType;

typedef enum ReaderResult {
  Ok,
  RawOnly,
  ReaderEOF,
  PPACError,
} ReaderResult;

/**
 * Serialized packet format
 */
typedef enum SerializedFormat {
  JSON,
  MessagePack,
  MessagePackNamed,
} SerializedFormat;

typedef enum SocketResult {
  Ready,
  Blocked,
  NoSocket,
  SocketError,
} SocketResult;

typedef struct Connection Connection;

typedef struct PPACReader PPACReader;

typedef struct Packet Packet;

typedef struct PacketWorker PacketWorker;

typedef struct SocketFactory SocketFactory;

/**
 * Fat pointer to data.
 */
typedef struct DataBuffer {
  const uint8_t *ptr;
  size_t size;
} DataBuffer;

typedef struct PacketData {
  /**
   * When was the packet stored (in secs).
   */
  uint64_t time;
  /**
   * Where the packet was heading.
   */
  enum Direction direction;
  /**
   * Which client version produced this packet.
   */
  enum PacketType protocol_type;
  /**
   * Parsed packet (if requested)
   */
  struct Packet *data;
  /**
   * Raw packet (if requested)
   */
  const uint8_t *raw_ptr;
  size_t raw_size;
} PacketData;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

uint32_t get_api_version(void);

uint32_t get_protocol_version(void);

/**
 * Returns whether the library is built with connection support.
 */
bool have_connection(void);

/**
 * Returns whether the library is built with PPAC support.
 */
bool have_ppac(void);

/**
 * Creates a new packet worker.
 */
struct PacketWorker *new_worker(enum PacketType packet_type, enum SerializedFormat serde_format);

/**
 * Destroys a packet worker.
 */
void free_worker(struct PacketWorker *_worker);

/**
 * Destroys a packet.
 */
void free_packet(struct Packet *_packet);

/**
 * Clones the packet.
 */
struct Packet *clone_packet(const struct Packet *packet);

/**
 * Checks if the packet is empty.
 */
bool packet_is_empty(const struct Packet *packet);

/**
 * Sets a new packet type.
 */
void set_packet_type(struct PacketWorker *worker, enum PacketType packet_type);

/**
 * Sets a new serde format.
 */
void set_serde_format(struct PacketWorker *worker, enum SerializedFormat format);

/**
 * Checks if the specified serde format is supported.
 */
bool serde_supported(enum SerializedFormat serde_format);

/**
 * Parses raw packet data and returns a [`Packet`] type or a null pointer if an error occured.
 *
 * # Safety
 * `data_ptr' must point to valid packet data up to `size` bytes.
 */
struct Packet *raw_to_packet(struct PacketWorker *worker, const uint8_t *data_ptr, size_t size);

/**
 * Parses serialized packet data and returns a [`Packet`] type or a null pointer if an error
 * occurred.
 *
 * # Safety
 * `data_ptr' must point to valid serialied data up to `size` bytes.
 */
struct Packet *ser_to_packet(struct PacketWorker *worker, const uint8_t *data_ptr, size_t size);

/**
 * Parses [`Packet`] and returns raw packet data.
 *
 * # Safety
 * The returned pointer is only valid until the next data-returning function call.
 * If the returned array is empty, the pointer might be non-null but still invalid. This is not
 * considered an error.
 */
struct DataBuffer packet_to_raw(struct PacketWorker *worker, const struct Packet *packet);

/**
 * Parses [`Packet`] and returns serialized packet data or a null pointer if an error occured.
 *
 * # Safety
 * The returned pointer is only valid until the next data-returning function call.
 * If the returned array is empty, the pointer might be non-null but still invalid. This is not
 * considered an error.
 */
struct DataBuffer packet_to_ser(struct PacketWorker *worker, const struct Packet *packet);

/**
 * Parses packet data and returns a fat pointer to the serialized packet or a null pointer if
 * an error occurred.
 *
 * # Safety
 * `data_ptr' must point to valid packet data up to `size` bytes.
 *
 * The returned pointer is only valid until the next data-returning function call.
 * If the returned array is empty, the pointer might be non-null but still invalid. This is not
 * considered an error.
 */
struct DataBuffer parse_packet(struct PacketWorker *worker, const uint8_t *data_ptr, size_t size);

/**
 * Deserializes packet and returns a fat pointer to the packet data or a null pointer if an error
 * occured.
 *
 * # Safety
 * `data_ptr' must point to valid packet data up to `size` bytes.
 *
 * The returned pointer is only valid until the next data-returning function call.
 * If the returned array is empty, the pointer might be non-null but still invalid. This is not
 * considered an error.
 */
struct DataBuffer create_packet(struct PacketWorker *worker, const uint8_t *data_ptr, size_t size);

/**
 * Returns a pointer to a UTF-8-encoded zero-terminated error string or a null pointer if no error
 * occurred.
 *
 * # Safety
 * The returned pointer is only valid until the next failable function call.
 */
const uint8_t *get_pw_error(const struct PacketWorker *worker);

/**
 * Creates a new socket factory.
 */
struct SocketFactory *new_factory(void);

/**
 * Destroys a socket factory.
 */
void free_factory(struct SocketFactory *_factory);

/**
 * Creates a new listener on the specified address.
 */
bool create_listener(struct SocketFactory *factory, const int8_t *addr);

/**
 * Sets the blocking mode of the listener.
 */
void listener_nonblocking(const struct SocketFactory *factory, bool nonblocking);

/**
 * Accepts a new incoming connection from installed listener. To collect the resulting connection
 * call `get_connection` or `stream_into_fd".
 */
enum SocketResult accept_listener(struct SocketFactory *factory);

/**
 * Creates a new stream to the specified address. To collect the resulting stream
 * call `get_connection` or `stream_into_fd".
 */
bool create_stream(struct SocketFactory *factory, const int8_t *addr);

/**
 * Sets the blocking mode of the stream.
 */
void stream_nonblocking(struct SocketFactory *factory, bool nonblocking);

/**
 * Returns the IP address of the stream.
 */
uint32_t get_stream_ip(const struct SocketFactory *factory);

/**
 * Creates a new connection from incoming connection.
 *
 * # Safety
 * 'in_key' must either be null or it must point to a UTF-8-encoded, zero-terminated
 * path to a PKCS#8 file containing a private key for decryption.
 * 'out_key' must either be null or it must point to a UTF-8-encoded, zero-terminated
 * path to a PKCS#8 file containing a public key for encryption.
 */
struct Connection *get_connection(struct SocketFactory *factory,
                                  enum PacketType packet_type,
                                  const int8_t *in_key,
                                  const int8_t *out_key);

/**
 * Returns an incoming connection descriptor. Caller is responsible for closing the returned descriptor.
 * If no stream was opened, returns -1.
 */
int64_t stream_into_fd(struct SocketFactory *factory);

/**
 * Clones the descriptor. Returns the cloned descriptor or -1 if an error occurred.
 */
int64_t clone_fd(struct SocketFactory *factory, int64_t fd);

/**
 * Closes the file descriptor.
 */
void close_fd(int64_t fd);

/**
 * Returns an owned socket descriptor. Caller is responsible for closing the returned descriptor.
 * If no listener was opened, returns -1.
 */
int64_t listener_into_fd(struct SocketFactory *factory);

/**
 * Installs the provided listener. This function takes ownership of the descriptor.
 *
 * # Safety
 * `fd` must be a valid descriptor.
 */
bool listener_from_fd(struct SocketFactory *factory, int64_t fd);

/**
 * Returns a pointer to a UTF-8-encoded zero-terminated error string or a null pointer if no error
 * occurred.
 *
 * # Safety
 * The returned pointer is only valid until the next failable function call.
 */
const uint8_t *get_sf_error(const struct SocketFactory *factory);

/**
 * Creates a new connection from owned socket descriptor.
 *
 * # Safety
 * `fd` must be a valid descriptor.
 *
 * 'in_key' must either be null or it must point to a UTF-8-encoded, zero-terminated
 * path to a PKCS#8 file containing a private key for decryption.
 * 'out_key' must either be null or it must point to a UTF-8-encoded, zero-terminated
 * path to a PKCS#8 file containing a public key for encryption.
 */
struct Connection *new_connection(int64_t fd,
                                  enum PacketType packet_type,
                                  const int8_t *in_key,
                                  const int8_t *out_key);

/**
 * Destroys a connection.
 */
void free_connection(struct Connection *_conn);

/**
 * Returns the IP address of the connection.
 */
uint32_t get_conn_ip(const struct Connection *conn);

/**
 * Changes the connection's packet type.
 */
void conn_set_packet_type(struct Connection *conn, enum PacketType packet_type);

/**
 * Returns a [`Packet`] or a null pointer if no connection was provided.
 *
 * # Safety
 * The returned pointer is only valid until the next data-returning function call.
 * If the returned array is empty, the pointer might be non-null but still invalid. This is not
 * considered an error.
 */
struct Packet *conn_get_data(struct Connection *conn);

/**
 * Reads a packet from the connection and stores it in the internal buffer. Call `conn_get_data`
 * to access it.
 */
enum SocketResult conn_read_packet(struct Connection *conn);

/**
 * Writes a packet to the connection. If `ptr` is null, flushes the buffer.
 *
 * # Note
 * If this function returns [`SocketResult::Blocked`], then the data has been written to the
 * buffer.
 */
enum SocketResult conn_write_packet(struct Connection *conn, const struct Packet *packet);

/**
 * Returns the encryption key (for [`Packet::EncryptionResponse`]).
 */
struct DataBuffer conn_get_key(struct Connection *conn);

/**
 * Returns a pointer to a UTF-8-encoded zero-terminated error string or a null pointer if no error
 * occurred.
 *
 * # Safety
 * The returned pointer is only valid until the next failable function call.
 */
const uint8_t *get_conn_error(const struct Connection *conn);

/**
 * Creates a new PPAC reader. After creation don't forget to check for errors.
 */
struct PPACReader *new_reader(const int8_t *path);

/**
 * Destroys the reader.
 */
void free_reader(struct PPACReader *_reader);

/**
 * Sets the output type.
 */
void set_out_type(struct PPACReader *reader, enum OutputType out_type);

/**
 * Reads the packet and returns if the function succeeded.
 */
enum ReaderResult read_packet(struct PPACReader *reader);

/**
 * Returns a pointer to the packet data or a null pointer if no data exists.
 *
 * # Note
 * [`data`] field is only returned once and must be freed by the caller.
 *
 * # Safety
 * The returned pointer is only valid until the next data-returning function call.
 * If the returned array is empty, the pointer might be non-null but still invalid. This is not
 * considered an error.
 */
struct PacketData get_reader_data(struct PPACReader *reader);

/**
 * Returns a pointer to a UTF-8-encoded zero-terminated error string or a null pointer if no error
 * occurred.
 *
 * # Safety
 * The returned pointer is only valid until the next failable function call.
 */
const uint8_t *get_reader_error(const struct PPACReader *reader);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* psopacketlib_ffi_h */
